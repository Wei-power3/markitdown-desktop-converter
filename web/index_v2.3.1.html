<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MarkItDown v2.3.1 - Phase 3 Complete (Task 4/7)</title>
    <style>
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-elevated: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --accent-blue: #38bdf8;
            --accent-green: #22c55e;
            --accent-red: #ef4444;
            --accent-yellow: #fbbf24;
            --accent-purple: #a855f7;
            --accent-orange: #fb923c;
            --border: #475569;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        .version-badge {
            display: inline-block;
            background: var(--accent-orange);
            color: var(--bg-primary);
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 700;
            margin-left: 10px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
            margin-bottom: 15px;
        }

        .features {
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
            color: var(--text-muted);
            flex-wrap: wrap;
        }

        .feature {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .new-badge {
            background: var(--accent-orange);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 700;
            margin-left: 5px;
        }

        .quality-banner {
            background: linear-gradient(135deg, rgba(251, 146, 60, 0.1), rgba(168, 85, 247, 0.1));
            border: 1px solid var(--accent-orange);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .quality-banner h3 {
            color: var(--accent-orange);
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .quality-features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .quality-item {
            display: flex;
            align-items: start;
            gap: 10px;
        }

        .quality-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .dropzone {
            background: var(--bg-secondary);
            border: 3px dashed var(--border);
            border-radius: 12px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }

        .dropzone:hover {
            border-color: var(--accent-blue);
            background: rgba(56, 189, 248, 0.05);
            transform: translateY(-2px);
        }

        .dropzone.drag-over {
            border-color: var(--accent-blue);
            background: rgba(56, 189, 248, 0.1);
            transform: scale(1.02);
        }

        .dropzone-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .dropzone-text {
            font-size: 1.3rem;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .dropzone-hint {
            color: var(--text-muted);
            font-size: 0.95rem;
        }

        .supported-formats {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .format-badge {
            background: var(--bg-elevated);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .queue-section {
            margin-top: 30px;
        }

        .queue-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .queue-title {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(125px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 20px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .job-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.2s ease;
        }

        .job-item:hover {
            border-color: var(--accent-blue);
        }

        .job-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 15px;
        }

        .job-info {
            flex: 1;
            min-width: 0;
        }

        .job-filename {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            word-break: break-word;
        }

        .job-meta {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .status-badge {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            white-space: nowrap;
        }

        .status-processing {
            background: rgba(56, 189, 248, 0.2);
            color: var(--accent-blue);
        }

        .status-completed {
            background: rgba(34, 197, 94, 0.2);
            color: var(--accent-green);
        }

        .status-error {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-red);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-elevated);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-blue);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .progress-fill.completed {
            background: var(--accent-green);
        }

        .quality-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(95px, 1fr));
            gap: 10px;
            margin-top: 10px;
            padding: 15px;
            background: var(--bg-elevated);
            border-radius: 8px;
        }

        .metric {
            text-align: center;
        }

        .metric-label {
            font-size: 0.72rem;
            color: var(--text-muted);
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 1.2rem;
            font-weight: 700;
        }

        .metric-value.excellent {
            color: var(--accent-green);
        }

        .metric-value.good {
            color: var(--accent-blue);
        }

        .metric-value.warning {
            color: var(--accent-yellow);
        }

        .metric-value.link-indicator {
            color: var(--accent-purple);
        }

        .metric-value.advanced-indicator {
            color: var(--accent-orange);
        }

        .job-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            background: #0ea5e9;
            transform: translateY(-1px);
        }

        .btn-success {
            background: var(--accent-green);
            color: var(--bg-primary);
        }

        .btn-success:hover {
            background: #16a34a;
            transform: translateY(-1px);
        }

        .btn-danger {
            background: transparent;
            color: var(--accent-red);
            border: 1px solid var(--accent-red);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        .empty-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--accent-red);
            color: var(--accent-red);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        input[type="file"] {
            display: none;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .spinner {
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .features {
                font-size: 0.8rem;
            }

            .dropzone {
                padding: 40px 20px;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .quality-metrics {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>
                üìÑ MarkItDown Converter
                <span class="version-badge">v2.3.1 (Task 4/7)</span>
            </h1>
            <p class="subtitle">PDF & PowerPoint to Markdown ‚Ä¢ Phase 3 in progress</p>
            <div class="features">
                <span class="feature">‚úì No Upload Required</span>
                <span class="feature">‚úì Complete Privacy</span>
                <span class="feature">‚úì Batch Processing</span>
                <span class="feature">‚úì Multi-Column Detection</span>
                <span class="feature">‚úì Header/Footer Removal</span>
                <span class="feature">‚úì Footnote Cleanup <span class="new-badge">TESTING</span></span>
            </div>
        </header>

        <div class="quality-banner">
            <h3>üöß v2.3.1 Development: Phase 3 Complete (Task 4/7)</h3>
            <div class="quality-features">
                <div class="quality-item">
                    <span class="quality-icon">üßπ</span>
                    <div>
                        <strong>Footnote Text Removal <span class="new-badge">TESTING</span></strong>
                        <div style="font-size: 0.85rem; color: var(--text-muted);">Removes footnote text from page bottoms (prevents duplication)</div>
                    </div>
                </div>
                <div class="quality-item">
                    <span class="quality-icon">üîó</span>
                    <div>
                        <strong>Marker-to-Footnote Matching</strong>
                        <div style="font-size: 0.85rem; color: var(--text-muted);">Smart number matching creates marker ‚Üí footnote mapping</div>
                    </div>
                </div>
                <div class="quality-item">
                    <span class="quality-icon">üìù</span>
                    <div>
                        <strong>Footnote Content Extraction</strong>
                        <div style="font-size: 0.85rem; color: var(--text-muted);">Extracts footnote text from page bottoms (last 15-20% of page)</div>
                    </div>
                </div>
                <div class="quality-item">
                    <span class="quality-icon">üì∞</span>
                    <div>
                        <strong>Multi-Column Layout Detection</strong>
                        <div style="font-size: 0.85rem; color: var(--text-muted);">Correctly reads 2-column academic papers</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="dropzone" class="dropzone">
            <div class="dropzone-icon">üìÅ</div>
            <div class="dropzone-text">Drag & Drop files here</div>
            <div class="dropzone-hint">or click to browse</div>
            <div class="supported-formats">
                <span class="format-badge">PDF</span>
                <span class="format-badge">PPTX</span>
                <span class="format-badge">PPT</span>
            </div>
            <input type="file" id="fileInput" accept=".pdf,.pptx,.ppt" multiple>
        </div>

        <div class="queue-section">
            <div class="queue-header">
                <h2 class="queue-title">Conversion Queue</h2>
            </div>

            <div class="stats" id="stats">
                <div class="stat-card">
                    <div class="stat-value" id="totalFiles">0</div>
                    <div class="stat-label">Total Files</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="processing">0</div>
                    <div class="stat-label">Processing</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="completed">0</div>
                    <div class="stat-label">Completed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="failed">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalLinks">0</div>
                    <div class="stat-label">Links Preserved</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalHeadersRemoved">0</div>
                    <div class="stat-label">H/F Removed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalMarkers">0</div>
                    <div class="stat-label">Markers</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalFootnotes">0</div>
                    <div class="stat-label">Extracted</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalMatches">0</div>
                    <div class="stat-label">FN Matches</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalRemoved">0</div>
                    <div class="stat-label">FN Removed</div>
                </div>
            </div>

            <div id="jobList"></div>

            <div class="empty-state" id="emptyState">
                <div class="empty-icon">üì≠</div>
                <p>No files yet. Drop some files above to get started!</p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const jobs = [];

        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const jobList = document.getElementById('jobList');
        const emptyState = document.getElementById('emptyState');

        dropzone.addEventListener('click', () => fileInput.click());
        
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('drag-over');
        });

        dropzone.addEventListener('dragleave', () => {
            dropzone.classList.remove('drag-over');
        });

        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files);
            handleFiles(files);
        });

        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            handleFiles(files);
            fileInput.value = '';
        });

        function handleFiles(files) {
            files.forEach(file => {
                const extension = file.name.split('.').pop().toLowerCase();
                if (['pdf', 'pptx', 'ppt'].includes(extension)) {
                    addJob(file);
                } else {
                    alert(`Unsupported file type: ${file.name}`);
                }
            });
        }

        function addJob(file) {
            const job = {
                id: Date.now() + Math.random(),
                filename: file.name,
                file: file,
                status: 'processing',
                progress: 0,
                result: null,
                error: null,
                createdAt: new Date(),
                qualityMetrics: null,
                linkMetadata: {
                    linksFound: 0,
                    linksPreserved: 0,
                    linkTypes: { external: 0, internal: 0 }
                },
                advancedMetadata: {
                    headersFootersRemoved: 0,
                    columnsDetected: 0,
                    footnotesDetected: 0,
                    footnoteMarkersDetected: 0,
                    footnoteMatches: 0,
                    footnoteTextItemsRemoved: 0  // NEW: Track removed text items
                }
            };

            jobs.unshift(job);
            updateUI();
            processFile(job);
        }

        // v2.3.1 Task 1: Detect footnote markers in text
        function detectFootnoteMarkers(textItems) {
            const markers = [];
            const bracketPattern = /\[(\d+)\]/g;
            const parenPattern = /(\d+)\)/g;
            const standalonePattern = /(?<=\s)(\d+)(?=\s|$|[,.])/g;
            const superscriptPattern = /[¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ‚Å∞]+/g;
            
            textItems.forEach(item => {
                const text = item.text;
                let match;
                
                while ((match = bracketPattern.exec(text)) !== null) {
                    markers.push({
                        marker: match[0],
                        number: match[1],
                        type: 'bracket',
                        text: item.text,
                        x: item.x,
                        y: item.y,
                        pageNum: item.pageNum,
                        fontSize: item.fontSize
                    });
                }
                
                bracketPattern.lastIndex = 0;
                while ((match = parenPattern.exec(text)) !== null) {
                    markers.push({
                        marker: match[0],
                        number: match[1],
                        type: 'paren',
                        text: item.text,
                        x: item.x,
                        y: item.y,
                        pageNum: item.pageNum,
                        fontSize: item.fontSize
                    });
                }
                
                parenPattern.lastIndex = 0;
                if (item.fontSize && item.fontSize < 8) {
                    while ((match = standalonePattern.exec(text)) !== null) {
                        markers.push({
                            marker: match[0],
                            number: match[1],
                            type: 'superscript',
                            text: item.text,
                            x: item.x,
                            y: item.y,
                            pageNum: item.pageNum,
                            fontSize: item.fontSize
                        });
                    }
                }
                
                standalonePattern.lastIndex = 0;
                while ((match = superscriptPattern.exec(text)) !== null) {
                    const superscriptMap = '‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ';
                    const number = match[0].split('').map(c => superscriptMap.indexOf(c).toString()).join('');
                    
                    markers.push({
                        marker: match[0],
                        number: number,
                        type: 'unicode',
                        text: item.text,
                        x: item.x,
                        y: item.y,
                        pageNum: item.pageNum,
                        fontSize: item.fontSize
                    });
                }
            });
            
            return markers;
        }

        // v2.3.1 Task 2: Extract footnote content from page bottoms
        function extractFootnoteContent(allPageItems, numPages, avgFontSize) {
            const footnotes = [];
            
            for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                const pageItems = allPageItems.filter(item => item.pageNum === pageNum);
                if (pageItems.length === 0) continue;
                
                const yPositions = pageItems.map(item => item.y);
                const minY = Math.min(...yPositions);
                const maxY = Math.max(...yPositions);
                const pageHeight = maxY - minY;
                
                const footnoteThreshold = minY + (pageHeight * 0.80);
                
                const footnoteRegionItems = pageItems.filter(item => {
                    const isInFootnoteRegion = item.y <= footnoteThreshold;
                    const hasSmallFont = item.fontSize < avgFontSize * 0.85;
                    return isInFootnoteRegion && hasSmallFont;
                });
                
                if (footnoteRegionItems.length === 0) continue;
                
                footnoteRegionItems.sort((a, b) => b.y - a.y);
                
                const footnoteStartPatterns = [
                    /^\[(\d+)\]\s*(.+)/,
                    /^(\d+)\)\s*(.+)/,
                    /^(\d+)\s+(.+)/
                ];
                
                let currentFootnote = null;
                let lastY = null;
                
                footnoteRegionItems.forEach(item => {
                    const text = item.text.trim();
                    if (!text) return;
                    
                    let isNewFootnote = false;
                    let footnoteNumber = null;
                    let footnoteContent = null;
                    
                    for (const pattern of footnoteStartPatterns) {
                        const match = text.match(pattern);
                        if (match) {
                            isNewFootnote = true;
                            footnoteNumber = match[1];
                            footnoteContent = match[2] || match[1];
                            break;
                        }
                    }
                    
                    if (isNewFootnote) {
                        if (currentFootnote) {
                            footnotes.push(currentFootnote);
                        }
                        
                        currentFootnote = {
                            number: footnoteNumber,
                            content: footnoteContent,
                            pageNum: pageNum,
                            y: item.y,
                            fontSize: item.fontSize
                        };
                        lastY = item.y;
                    } else if (currentFootnote) {
                        const yDifference = Math.abs(item.y - lastY);
                        if (yDifference < item.fontSize * 2) {
                            currentFootnote.content += ' ' + text;
                            lastY = item.y;
                        }
                    }
                });
                
                if (currentFootnote) {
                    footnotes.push(currentFootnote);
                }
            }
            
            return footnotes;
        }

        // v2.3.1 Task 3: Match markers to footnotes
        function matchMarkersToFootnotes(markers, footnotes) {
            console.log('[Task 3] Starting marker-to-footnote matching...');
            console.log(`[Task 3] Input: ${markers.length} markers, ${footnotes.length} footnotes`);
            
            const footnoteMap = new Map();
            footnotes.forEach(fn => {
                const num = fn.number.toString();
                if (!footnoteMap.has(num)) {
                    footnoteMap.set(num, []);
                }
                footnoteMap.get(num).push(fn);
            });
            
            console.log('[Task 3] Footnote numbers available:', Array.from(footnoteMap.keys()));
            
            const matches = [];
            const unmatchedMarkers = [];
            
            markers.forEach(marker => {
                const num = marker.number.toString();
                
                if (footnoteMap.has(num)) {
                    const footnoteOptions = footnoteMap.get(num);
                    let bestFootnote = footnoteOptions[0];
                    let minPageDiff = Math.abs(marker.pageNum - footnoteOptions[0].pageNum);
                    
                    for (let i = 1; i < footnoteOptions.length; i++) {
                        const pageDiff = Math.abs(marker.pageNum - footnoteOptions[i].pageNum);
                        if (pageDiff < minPageDiff) {
                            minPageDiff = pageDiff;
                            bestFootnote = footnoteOptions[i];
                        }
                    }
                    
                    matches.push({
                        marker: marker,
                        footnote: bestFootnote,
                        markerNumber: num,
                        footnoteContent: bestFootnote.content,
                        markerPage: marker.pageNum,
                        footnotePage: bestFootnote.pageNum
                    });
                } else {
                    unmatchedMarkers.push(marker);
                }
            });
            
            const matchedFootnoteNumbers = new Set(matches.map(m => m.markerNumber));
            const orphanedFootnotes = footnotes.filter(fn => !matchedFootnoteNumbers.has(fn.number.toString()));
            
            const matchRate = markers.length > 0 ? (matches.length / markers.length * 100).toFixed(1) : 0;
            
            console.log(`[Task 3] ‚úì Matched: ${matches.length}/${markers.length} markers (${matchRate}%)`);
            console.log(`[Task 3] ‚úó Unmatched markers: ${unmatchedMarkers.length}`);
            console.log(`[Task 3] ‚ö† Orphaned footnotes: ${orphanedFootnotes.length}`);
            
            if (matches.length > 0) {
                console.log('[Task 3] Sample matches:', matches.slice(0, 3).map(m => ({
                    marker: m.markerNumber,
                    content: m.footnoteContent.substring(0, 50) + '...'
                })));
            }
            
            if (unmatchedMarkers.length > 0) {
                console.log('[Task 3] Unmatched marker numbers:', unmatchedMarkers.map(m => m.number));
            }
            
            if (orphanedFootnotes.length > 0) {
                console.log('[Task 3] Orphaned footnote numbers:', orphanedFootnotes.map(fn => fn.number));
            }
            
            return {
                matches: matches,
                unmatchedMarkers: unmatchedMarkers,
                orphanedFootnotes: orphanedFootnotes,
                matchRate: parseFloat(matchRate),
                totalMarkers: markers.length,
                totalFootnotes: footnotes.length,
                matchedCount: matches.length
            };
        }

        // v2.3.1 Task 4: Remove footnote text from page bottoms
        function removeFootnoteTextFromPages(allPageItems, extractedFootnotes, numPages, avgFontSize) {
            console.log('[Task 4] Starting footnote text removal from page bottoms...');
            console.log(`[Task 4] Input: ${allPageItems.length} text items, ${extractedFootnotes.length} footnotes to remove`);
            
            const itemsBeforeRemoval = allPageItems.length;
            
            // Create a set of y-coordinates and page numbers where footnotes were found
            const footnotePositions = new Set();
            extractedFootnotes.forEach(fn => {
                footnotePositions.add(`${fn.pageNum}-${fn.y}`);
            });
            
            // Filter out items in footnote regions
            const cleanedItems = [];
            let removedCount = 0;
            
            for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                const pageItems = allPageItems.filter(item => item.pageNum === pageNum);
                if (pageItems.length === 0) continue;
                
                // Calculate footnote threshold for this page
                const yPositions = pageItems.map(item => item.y);
                const minY = Math.min(...yPositions);
                const maxY = Math.max(...yPositions);
                const pageHeight = maxY - minY;
                const footnoteThreshold = minY + (pageHeight * 0.80);
                
                // Filter items: keep body text, remove footnote region
                pageItems.forEach(item => {
                    const isInFootnoteRegion = item.y <= footnoteThreshold;
                    const hasSmallFont = item.fontSize < avgFontSize * 0.85;
                    const isFootnoteText = isInFootnoteRegion && hasSmallFont;
                    
                    if (isFootnoteText) {
                        removedCount++;
                    } else {
                        cleanedItems.push(item);
                    }
                });
            }
            
            const itemsAfterRemoval = cleanedItems.length;
            const removalRate = itemsBeforeRemoval > 0 ? ((removedCount / itemsBeforeRemoval) * 100).toFixed(1) : 0;
            
            console.log(`[Task 4] ‚úì Removed: ${removedCount} text items from footnote regions`);
            console.log(`[Task 4] ‚úì Kept: ${itemsAfterRemoval} body text items`);
            console.log(`[Task 4] ‚úì Removal rate: ${removalRate}% of total items`);
            console.log(`[Task 4] Pages are now clean and ready for inline footnote insertion`);
            
            return {
                cleanedItems: cleanedItems,
                removedCount: removedCount,
                keptCount: itemsAfterRemoval,
                removalRate: parseFloat(removalRate)
            };
        }

        function cleanText(text) {
            let cleaned = text;
            cleaned = cleaned.replace(/(\w+)\s+fi\s+(\w+)/g, '$1fi$2');
            cleaned = cleaned.replace(/(\w+)\s+fl\s+(\w+)/g, '$1fl$2');
            cleaned = cleaned.replace(/([a-z])(on|to|in|at|of|as|by|or|an|is|be|we)a([A-Z])/g, '$1 $2 a $3');
            cleaned = cleaned.replace(/([a-z])(on|to|in|at|of|as|by|or|an|is|be|we)the([A-Z])/g, '$1 $2 the $3');
            cleaned = cleaned.replace(/(\w+)(ona|toa|ina|ata|ofa|asa|bya)([a-z]{4,})/g, (match, before, middle, after) => {
                const prep = middle.slice(0, -1);
                return `${before} ${prep} a ${after}`;
            });
            const ligatureMap = {'Ô¨Å': 'fi', 'Ô¨Ç': 'fl', 'Ô¨Ä': 'ff', 'Ô¨É': 'ffi', 'Ô¨Ñ': 'ffl', 'Ô¨Ü': 'st', 'Ô¨Ö': 'ft'};
            Object.entries(ligatureMap).forEach(([lig, rep]) => {
                cleaned = cleaned.replace(new RegExp(lig, 'g'), rep);
            });
            cleaned = cleaned.replace(/(\w+)-\s+(\w+)/g, '$1$2');
            cleaned = cleaned.replace(/([a-z])\s+([a-z])\s+([a-z])/g, (match, a, b, c) => {
                if (match.toLowerCase() !== match) return match;
                return a + b + c;
            });
            cleaned = cleaned.replace(/\s+/g, ' ').trim();
            cleaned = cleaned.replace(/√¢‚Ç¨‚Ñ¢/g, "'").replace(/√¢‚Ç¨≈ì/g, '"').replace(/√¢‚Ç¨/g, '"').replace(/√¢‚Ç¨"/g, '‚Äî').replace(/√Ç/g, '');
            return cleaned;
        }

        function calculateQualityMetrics(text, linkMetadata, advancedMetadata) {
            const totalChars = text.length;
            const ligatureArtifacts = (text.match(/Ô¨Å|Ô¨Ç|Ô¨Ä|Ô¨É|Ô¨Ñ/g) || []).length;
            const spacedLigatures = (text.match(/(\w+)\s+fi\s+(\w+)|(\w+)\s+fl\s+(\w+)/g) || []).length;
            const hyphenationIssues = (text.match(/\w+-\s+\w+/g) || []).length;
            const spacingIssues = (text.match(/[a-z]\s[a-z]\s[a-z]/g) || []).length;
            const encodingIssues = (text.match(/√¢‚Ç¨|√Ç(?!\w)/g) || []).length;
            const totalIssues = ligatureArtifacts + spacedLigatures + hyphenationIssues + spacingIssues + encodingIssues;
            const cleanScore = Math.max(0, 100 - (totalIssues / totalChars * 1000));
            const hasHeaders = /^#+ /m.test(text);
            const hasTables = /\|.*\|/m.test(text);
            const hasLists = /^[-*+] /m.test(text);
            const hasBoldItalic = /\*\*.*\*\*|\*.*\*/m.test(text);
            const headerCount = (text.match(/^#+ /gm) || []).length;
            const listCount = (text.match(/^[-*+] /gm) || []).length;
            const linkCount = (text.match(/\[.*?\]\(http.*?\)/g) || []).length;
            let structureScore = 0;
            if (headerCount > 0) structureScore += 25;
            if (headerCount >= 3) structureScore += 10;
            if (hasTables) structureScore += 15;
            if (listCount > 0) structureScore += 15;
            if (listCount >= 5) structureScore += 10;
            if (hasBoldItalic) structureScore += 10;
            if (linkCount > 0) structureScore += 15;
            if (advancedMetadata.headersFootersRemoved > 0) structureScore += 5;
            if (advancedMetadata.columnsDetected > 0) structureScore += 10;
            structureScore = Math.min(100, structureScore);
            const overallScore = Math.round((cleanScore * 0.5) + (structureScore * 0.5));
            return {
                cleanScore: Math.round(cleanScore),
                structureScore: Math.round(structureScore),
                overallScore: overallScore,
                issuesFixed: totalIssues,
                linksPreserved: linkMetadata.linksPreserved,
                linkPreservationRate: linkMetadata.linksFound > 0 ? Math.round((linkMetadata.linksPreserved / linkMetadata.linksFound) * 100) : 0,
                headersFootersRemoved: advancedMetadata.headersFootersRemoved,
                columnsDetected: advancedMetadata.columnsDetected,
                footnotesDetected: advancedMetadata.footnotesDetected,
                footnoteMarkersDetected: advancedMetadata.footnoteMarkersDetected,
                footnoteMatches: advancedMetadata.footnoteMatches,
                footnoteMatchRate: advancedMetadata.footnoteMatchRate || 0,
                footnoteTextItemsRemoved: advancedMetadata.footnoteTextItemsRemoved || 0
            };
        }

        async function processFile(job) {
            try {
                job.progress = 10;
                updateUI();
                const extension = job.filename.split('.').pop().toLowerCase();
                let markdown;
                let linkMetadata = { linksFound: 0, linksPreserved: 0, linkTypes: { external: 0, internal: 0 } };
                let advancedMetadata = { headersFootersRemoved: 0, columnsDetected: 0, footnotesDetected: 0, footnoteMarkersDetected: 0, footnoteMatches: 0, footnoteMatchRate: 0, footnoteTextItemsRemoved: 0 };
                if (extension === 'pdf') {
                    const result = await convertPDF(job);
                    markdown = result.markdown;
                    linkMetadata = result.linkMetadata;
                    advancedMetadata = result.advancedMetadata;
                } else if (extension === 'pptx' || extension === 'ppt') {
                    const result = await convertPPTX(job);
                    markdown = result.markdown;
                    linkMetadata = result.linkMetadata;
                }
                job.linkMetadata = linkMetadata;
                job.advancedMetadata = advancedMetadata;
                job.progress = 85;
                updateUI();
                const cleanedMarkdown = cleanText(markdown);
                job.progress = 95;
                updateUI();
                job.qualityMetrics = calculateQualityMetrics(cleanedMarkdown, linkMetadata, advancedMetadata);
                job.progress = 100;
                job.status = 'completed';
                job.result = cleanedMarkdown;
                updateUI();
            } catch (error) {
                console.error('Conversion error:', error);
                job.status = 'error';
                job.error = error.message || 'Conversion failed';
                updateUI();
            }
        }

        function detectHeadersFooters(allPageItems, numPages) {
            const textFrequency = new Map();
            allPageItems.forEach(item => {
                const text = item.text.trim();
                if (text.length < 3) return;
                if (!textFrequency.has(text)) {
                    textFrequency.set(text, { count: 0, pages: new Set(), positions: [] });
                }
                const entry = textFrequency.get(text);
                entry.count++;
                entry.pages.add(item.pageNum);
                entry.positions.push({ y: item.y, pageNum: item.pageNum });
            });
            const threshold = Math.max(2, Math.floor(numPages * 0.5));
            const headersFooters = new Set();
            textFrequency.forEach((data, text) => {
                if (data.pages.size >= threshold) {
                    const isPageNumber = /^\d+$/.test(text) || /^page\s+\d+$/i.test(text);
                    const isDOI = /doi:\s*10\.\d+/i.test(text);
                    const isJournalName = text.length > 10 && text.split(' ').length > 2;
                    const isShortRepetitive = text.length < 50;
                    if (isPageNumber || isDOI || (isJournalName && isShortRepetitive)) {
                        headersFooters.add(text);
                    }
                }
            });
            return headersFooters;
        }

        function detectColumnLayout(pageItems) {
            if (pageItems.length === 0) return { columns: 1, divider: null };
            const xPositions = pageItems.map(item => item.x).sort((a, b) => a - b);
            const minX = Math.min(...xPositions);
            const maxX = Math.max(...xPositions);
            const pageWidth = maxX - minX;
            const middleThird = { start: minX + pageWidth * 0.35, end: minX + pageWidth * 0.65 };
            const itemsInMiddle = pageItems.filter(item => item.x >= middleThird.start && item.x <= middleThird.end);
            const middleRatio = itemsInMiddle.length / pageItems.length;
            if (middleRatio < 0.1 && pageItems.length > 20) {
                const divider = minX + (pageWidth / 2);
                return { columns: 2, divider: divider };
            }
            return { columns: 1, divider: null };
        }

        function sortByColumns(pageItems, layout) {
            if (layout.columns === 1) {
                return pageItems.sort((a, b) => b.y - a.y);
            }
            const itemsWithColumn = pageItems.map(item => ({
                ...item,
                column: item.x < layout.divider ? 0 : 1
            }));
            return itemsWithColumn.sort((a, b) => {
                if (a.column !== b.column) return a.column - b.column;
                return b.y - a.y;
            });
        }

        async function extractPDFLinks(page, pageNum) {
            const annotations = await page.getAnnotations();
            const links = [];
            annotations.forEach(annotation => {
                if (annotation.subtype === 'Link') {
                    const link = {
                        url: annotation.url || null,
                        dest: annotation.dest || null,
                        rect: annotation.rect,
                        page: pageNum,
                        type: annotation.url ? 'external' : 'internal'
                    };
                    if (link.url || link.dest) {
                        links.push(link);
                    }
                }
            });
            return links;
        }

        function matchLinksToText(links, textItems) {
            const matchedLinks = [];
            links.forEach(link => {
                if (link.type === 'internal') return;
                const [x1, y1, x2, y2] = link.rect;
                const nearbyText = textItems.filter(item => {
                    const tolerance = 5;
                    return item.x >= (x1 - tolerance) && item.x <= (x2 + tolerance) && item.y >= (y1 - tolerance) && item.y <= (y2 + tolerance);
                });
                const linkText = nearbyText.map(item => item.text).join(' ').trim();
                if (link.url) {
                    matchedLinks.push({ text: linkText || new URL(link.url).hostname, url: link.url, type: link.type });
                }
            });
            return matchedLinks;
        }

        async function convertPDF(job) {
            job.progress = 20;
            updateUI();
            const arrayBuffer = await job.file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let markdown = `# ${job.filename}\n\n`;
            markdown += `Converted from PDF ‚Ä¢ ${pdf.numPages} pages ‚Ä¢ v2.3.1 (Tasks 1-4: Footnote Detection, Extraction, Matching & Removal)\n\n---\n\n`;
            let allLinks = [];
            const allItems = [];
            
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                textContent.items.forEach(item => {
                    allItems.push({
                        text: item.str,
                        fontSize: item.height,
                        fontName: item.fontName || '',
                        y: item.transform[5],
                        x: item.transform[4],
                        pageNum: i
                    });
                });
            }
            
            // Task 1: Detect footnote markers
            const footnoteMarkers = detectFootnoteMarkers(allItems);
            console.log(`[Task 1] Detected ${footnoteMarkers.length} footnote markers`);
            
            // Task 2: Extract footnote content
            const fontSizes = allItems.map(item => item.fontSize).filter(size => size > 0);
            const avgFontSize = fontSizes.reduce((a, b) => a + b, 0) / fontSizes.length;
            const extractedFootnotes = extractFootnoteContent(allItems, pdf.numPages, avgFontSize);
            console.log(`[Task 2] Extracted ${extractedFootnotes.length} footnotes`);
            
            // Task 3: Match markers to footnotes
            const matchResult = matchMarkersToFootnotes(footnoteMarkers, extractedFootnotes);
            console.log(`[Task 3] Match complete: ${matchResult.matchedCount} matches, ${matchResult.matchRate}% success rate`);
            
            // Task 4: Remove footnote text from page bottoms
            const removalResult = removeFootnoteTextFromPages(allItems, extractedFootnotes, pdf.numPages, avgFontSize);
            const cleanedItems = removalResult.cleanedItems;
            console.log(`[Task 4] Removal complete: ${removalResult.removedCount} items removed, ${removalResult.keptCount} items kept`);
            
            const headersFooters = detectHeadersFooters(cleanedItems, pdf.numPages);
            const ACADEMIC_KEYWORDS = ['Abstract', 'Introduction', 'Background', 'Literature Review', 'Methods', 'Methodology', 'Materials and Methods', 'Results', 'Findings', 'Discussion', 'Analysis', 'Conclusion', 'Conclusions', 'References', 'Bibliography', 'Acknowledgments', 'Appendix'];
            let totalColumnsDetected = 0;
            
            for (let i = 1; i <= pdf.numPages; i++) {
                job.progress = 20 + (60 * (i / pdf.numPages));
                updateUI();
                const page = await pdf.getPage(i);
                const pageLinks = await extractPDFLinks(page, i);
                allLinks.push(...pageLinks);
                markdown += `## Page ${i}\n\n`;
                
                // Use cleaned items (footnotes removed)
                const pageItems = cleanedItems.filter(item => item.pageNum === i).map(item => ({
                    text: item.text,
                    fontSize: item.fontSize,
                    fontName: item.fontName || '',
                    y: item.y,
                    x: item.x
                }));
                
                const filteredItems = pageItems.filter(item => {
                    const text = item.text.trim();
                    return !headersFooters.has(text);
                });
                const layout = detectColumnLayout(filteredItems);
                if (layout.columns === 2) totalColumnsDetected++;
                const sortedItems = sortByColumns(filteredItems, layout);
                let lastY = -1;
                let currentLine = [];
                sortedItems.forEach((item, idx) => {
                    const fontSize = item.fontSize;
                    const fontName = item.fontName || '';
                    const text = item.text.trim();
                    if (!text) return;
                    if (lastY !== -1 && Math.abs(item.y - lastY) > 5) {
                        if (currentLine.length > 0) {
                            const lineText = currentLine.map(i => i.text).join(' ');
                            markdown += processLine(lineText, currentLine[0].fontSize, currentLine[0].fontName, avgFontSize, ACADEMIC_KEYWORDS);
                        }
                        currentLine = [];
                    }
                    currentLine.push({ text, fontSize, fontName });
                    lastY = item.y;
                });
                if (currentLine.length > 0) {
                    const lineText = currentLine.map(i => i.text).join(' ');
                    markdown += processLine(lineText, currentLine[0].fontSize, currentLine[0].fontName, avgFontSize, ACADEMIC_KEYWORDS);
                }
                markdown += '\n';
            }
            
            const matchedLinks = matchLinksToText(allLinks, cleanedItems);
            matchedLinks.forEach(link => {
                if (link.text && link.text.length > 2) {
                    const escapedText = link.text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`\\b${escapedText}\\b`, 'g');
                    markdown = markdown.replace(regex, `[${link.text}](${link.url})`);
                }
            });
            
            const linkMetadata = {
                linksFound: allLinks.filter(l => l.type === 'external').length,
                linksPreserved: matchedLinks.length,
                linkTypes: { external: matchedLinks.length, internal: 0 }
            };
            
            const advancedMetadata = {
                headersFootersRemoved: headersFooters.size,
                columnsDetected: totalColumnsDetected,
                footnotesDetected: extractedFootnotes.length,
                footnoteMarkersDetected: footnoteMarkers.length,
                footnoteMatches: matchResult.matchedCount,
                footnoteMatchRate: matchResult.matchRate,
                footnoteTextItemsRemoved: removalResult.removedCount
            };
            
            return { markdown, linkMetadata, advancedMetadata };
        }

        function processLine(text, fontSize, fontName, avgFontSize, keywords) {
            if (!text.trim()) return '';
            let headerLevel = 0;
            if (fontSize >= avgFontSize * 1.8) headerLevel = 1;
            else if (fontSize >= avgFontSize * 1.5) headerLevel = 2;
            else if (fontSize >= avgFontSize * 1.2) headerLevel = 3;
            const isAcademicSection = keywords.some(keyword => text.trim().toLowerCase() === keyword.toLowerCase() || text.trim().toLowerCase().startsWith(keyword.toLowerCase() + ':'));
            if (isAcademicSection && headerLevel === 0) {
                headerLevel = 2;
            }
            const isBulletList = /^[\s]*[‚Ä¢\-‚Äì‚ñ†‚ñ°‚óã‚óè‚óæ‚óΩ‚ñ™‚ñ´][\s]/.test(text);
            const isNumberedList = /^[\s]*[\d]+[.)][\s]/.test(text);
            const isBold = fontName.toLowerCase().includes('bold') || fontName.includes('-B');
            const isItalic = fontName.toLowerCase().includes('italic') || fontName.includes('-I');
            let output = '';
            if (headerLevel > 0) {
                output = '#'.repeat(headerLevel) + ' ' + text + '\n\n';
            } else if (isBulletList) {
                output = '- ' + text.replace(/^[\s]*[‚Ä¢\-‚Äì‚ñ†‚ñ°‚óã‚óè‚óæ‚óΩ‚ñ™‚ñ´][\s]*/, '') + '\n';
            } else if (isNumberedList) {
                output = text + '\n';
            } else {
                let formattedText = text;
                if (isBold && isItalic) {
                    formattedText = `***${text}***`;
                } else if (isBold) {
                    formattedText = `**${text}**`;
                } else if (isItalic) {
                    formattedText = `*${text}*`;
                }
                output = formattedText + ' ';
            }
            return output;
        }

        async function extractPPTXHyperlinks(zip, slideFiles) {
            const allLinks = [];
            const relsPath = 'ppt/_rels/presentation.xml.rels';
            let relationships = {};
            if (zip.files[relsPath]) {
                const relsXml = await zip.files[relsPath].async('text');
                const parser = new DOMParser();
                const relsDoc = parser.parseFromString(relsXml, 'text/xml');
                const rels = relsDoc.getElementsByTagName('Relationship');
                Array.from(rels).forEach(rel => {
                    const id = rel.getAttribute('Id');
                    const target = rel.getAttribute('Target');
                    const type = rel.getAttribute('Type');
                    if (type && type.includes('hyperlink')) {
                        relationships[id] = target;
                    }
                });
            }
            for (let i = 0; i < slideFiles.length; i++) {
                const slideXml = await zip.files[slideFiles[i]].async('text');
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(slideXml, 'text/xml');
                const hyperlinks = xmlDoc.getElementsByTagName('a:hlinkClick');
                Array.from(hyperlinks).forEach(link => {
                    const rId = link.getAttribute('r:id');
                    const tooltip = link.getAttribute('tooltip');
                    const parent = link.parentElement;
                    const textElements = parent.getElementsByTagName('a:t');
                    const linkText = Array.from(textElements).map(t => t.textContent).join(' ').trim();
                    if (rId && relationships[rId]) {
                        allLinks.push({ text: linkText || tooltip || 'link', url: relationships[rId], slide: i + 1, type: 'external' });
                    }
                });
            }
            return allLinks;
        }

        async function convertPPTX(job) {
            job.progress = 20;
            updateUI();
            const arrayBuffer = await job.file.arrayBuffer();
            const zip = await JSZip.loadAsync(arrayBuffer);
            let markdown = `# ${job.filename}\n\n`;
            markdown += `Converted from PowerPoint ‚Ä¢ v2.3.1\n\n---\n\n`;
            const slideFiles = Object.keys(zip.files).filter(name => name.startsWith('ppt/slides/slide') && name.endsWith('.xml')).sort((a, b) => {
                const numA = parseInt(a.match(/slide(\d+)/)[1]);
                const numB = parseInt(b.match(/slide(\d+)/)[1]);
                return numA - numB;
            });
            job.progress = 40;
            updateUI();
            const allLinks = await extractPPTXHyperlinks(zip, slideFiles);
            for (let i = 0; i < slideFiles.length; i++) {
                job.progress = 40 + (40 * ((i + 1) / slideFiles.length));
                updateUI();
                const slideXml = await zip.files[slideFiles[i]].async('text');
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(slideXml, 'text/xml');
                markdown += `## Slide ${i + 1}\n\n`;
                const textElements = xmlDoc.getElementsByTagName('a:t');
                const texts = Array.from(textElements).map(el => el.textContent.trim()).filter(text => text.length > 0);
                if (texts.length > 0) {
                    texts.forEach(text => {
                        markdown += `- ${text}\n`;
                    });
                } else {
                    markdown += '*[No text content on this slide]*';
                }
                markdown += '\n\n';
            }
            allLinks.forEach(link => {
                if (link.text && link.text.length > 2) {
                    const escapedText = link.text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const regex = new RegExp(`(?<!\\[)\\b${escapedText}\\b(?!\\])`, 'g');
                    markdown = markdown.replace(regex, `[${link.text}](${link.url})`);
                }
            });
            const linkMetadata = {
                linksFound: allLinks.length,
                linksPreserved: allLinks.length,
                linkTypes: { external: allLinks.length, internal: 0 }
            };
            return { markdown, linkMetadata };
        }

        function updateUI() {
            document.getElementById('totalFiles').textContent = jobs.length;
            document.getElementById('processing').textContent = jobs.filter(j => j.status === 'processing').length;
            document.getElementById('completed').textContent = jobs.filter(j => j.status === 'completed').length;
            document.getElementById('failed').textContent = jobs.filter(j => j.status === 'error').length;
            const totalLinksPreserved = jobs.reduce((sum, job) => sum + (job.linkMetadata?.linksPreserved || 0), 0);
            document.getElementById('totalLinks').textContent = totalLinksPreserved;
            const totalHeadersRemoved = jobs.reduce((sum, job) => sum + (job.advancedMetadata?.headersFootersRemoved || 0), 0);
            document.getElementById('totalHeadersRemoved').textContent = totalHeadersRemoved;
            const totalMarkers = jobs.reduce((sum, job) => sum + (job.advancedMetadata?.footnoteMarkersDetected || 0), 0);
            document.getElementById('totalMarkers').textContent = totalMarkers;
            const totalFootnotes = jobs.reduce((sum, job) => sum + (job.advancedMetadata?.footnotesDetected || 0), 0);
            document.getElementById('totalFootnotes').textContent = totalFootnotes;
            const totalMatches = jobs.reduce((sum, job) => sum + (job.advancedMetadata?.footnoteMatches || 0), 0);
            document.getElementById('totalMatches').textContent = totalMatches;
            const totalRemoved = jobs.reduce((sum, job) => sum + (job.advancedMetadata?.footnoteTextItemsRemoved || 0), 0);
            document.getElementById('totalRemoved').textContent = totalRemoved;
            
            if (jobs.length === 0) {
                emptyState.style.display = 'block';
                jobList.innerHTML = '';
            } else {
                emptyState.style.display = 'none';
                jobList.innerHTML = jobs.map(job => renderJob(job)).join('');
            }
        }

        function renderJob(job) {
            const statusConfig = {
                processing: { icon: '‚è≥', class: 'status-processing', label: 'Processing' },
                completed: { icon: '‚úî', class: 'status-completed', label: 'Completed' },
                error: { icon: '‚úñ', class: 'status-error', label: 'Failed' }
            };
            const config = statusConfig[job.status];
            const fileSize = (job.file.size / 1024).toFixed(1) + ' KB';
            const time = job.createdAt.toLocaleTimeString();
            let qualityHTML = '';
            if (job.qualityMetrics) {
                const m = job.qualityMetrics;
                const getScoreClass = (score) => {
                    if (score >= 90) return 'excellent';
                    if (score >= 70) return 'good';
                    return 'warning';
                };
                qualityHTML = `
                    <div class="quality-metrics">
                        <div class="metric">
                            <div class="metric-label">Text</div>
                            <div class="metric-value ${getScoreClass(m.cleanScore)}">${m.cleanScore}%</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Structure</div>
                            <div class="metric-value ${getScoreClass(m.structureScore)}">${m.structureScore}%</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Links</div>
                            <div class="metric-value link-indicator">${m.linksPreserved}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">H/F</div>
                            <div class="metric-value advanced-indicator">${m.headersFootersRemoved || 0}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Markers</div>
                            <div class="metric-value advanced-indicator">${m.footnoteMarkersDetected || 0}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Extracted</div>
                            <div class="metric-value advanced-indicator">${m.footnotesDetected || 0}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Matched</div>
                            <div class="metric-value advanced-indicator">${m.footnoteMatches || 0}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Match%</div>
                            <div class="metric-value ${getScoreClass(m.footnoteMatchRate || 0)}">${m.footnoteMatchRate || 0}%</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Removed</div>
                            <div class="metric-value advanced-indicator">${m.footnoteTextItemsRemoved || 0}</div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Overall</div>
                            <div class="metric-value ${getScoreClass(m.overallScore)}">${m.overallScore}%</div>
                        </div>
                    </div>
                `;
            }
            return `
                <div class="job-item">
                    <div class="job-header">
                        <div class="job-info">
                            <div class="job-filename">
                                <span>${config.icon}</span>
                                <span>${job.filename}</span>
                            </div>
                            <div class="job-meta">${fileSize} ‚Ä¢ ${time}</div>
                        </div>
                        <span class="status-badge ${config.class}">${config.label}</span>
                    </div>
                    <div class="progress-bar">
                        <div class="progress-fill ${job.status === 'completed' ? 'completed' : ''}" style="width: ${job.progress}%"></div>
                    </div>
                    ${qualityHTML}
                    ${job.error ? `<div class="error-message"><strong>Error:</strong> ${job.error}</div>` : ''}
                    <div class="job-actions">
                        ${job.status === 'completed' ? `
                            <button class="btn btn-success" onclick="downloadMarkdown('${job.id}')">‚è© Download Markdown</button>
                            <button class="btn btn-primary" onclick="viewMarkdown('${job.id}')">üëÅ Preview</button>
                        ` : ''}
                        ${job.status !== 'processing' ? `<button class="btn btn-danger" onclick="deleteJob('${job.id}')">üóë Delete</button>` : ''}
                    </div>
                </div>
            `;
        }

        function downloadMarkdown(jobId) {
            const job = jobs.find(j => j.id == jobId);
            if (!job || !job.result) return;
            const blob = new Blob([job.result], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = job.filename.replace(/\.[^.]+$/, '') + '_v2.3.1_task4.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function viewMarkdown(jobId) {
            const job = jobs.find(j => j.id == jobId);
            if (!job || !job.result) return;
            const previewWindow = window.open('', '_blank');
            const metricsHTML = job.qualityMetrics ? `
                <div style="background: #1e293b; border: 1px solid #fb923c; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                    <h2 style="color: #fb923c; margin-bottom: 10px;">Quality Metrics (v2.3.1 - Tasks 1-4)</h2>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 15px;">
                        <div><div style="font-size: 0.9rem; color: #94a3b8;">Text Quality</div><div style="font-size: 1.8rem; font-weight: bold; color: #22c55e;">${job.qualityMetrics.cleanScore}%</div></div>
                        <div><div style="font-size: 0.9rem; color: #94a3b8;">Structure</div><div style="font-size: 1.8rem; font-weight: bold; color: #38bdf8;">${job.qualityMetrics.structureScore}%</div></div>
                        <div><div style="font-size: 0.9rem; color: #94a3b8;">External Links</div><div style="font-size: 1.8rem; font-weight: bold; color: #a855f7;">${job.qualityMetrics.linksPreserved}</div></div>
                        <div><div style="font-size: 0.9rem; color: #94a3b8;">H/F Removed</div><div style="font-size: 1.8rem; font-weight: bold; color: #fb923c;">${job.qualityMetrics.headersFootersRemoved || 0}</div></div>
                        <div><div style="font-size: 0.9rem; color: #94a3b8;">FN Markers</div><div style="font-size: 1.8rem; font-weight: bold; color: #fb923c;">${job.qualityMetrics.footnoteMarkersDetected || 0}</div></div>
                        <div><div style="font-size: 0.9rem; color: #94a3b8;">FN Extracted</div><div style="font-size: 1.8rem; font-weight: bold; color: #fb923c;">${job.qualityMetrics.footnotesDetected || 0}</div></div>
                        <div><div style="font-size: 0.9rem; color: #94a3b8;">FN Matched</div><div style="font-size: 1.8rem; font-weight: bold; color: #fb923c;">${job.qualityMetrics.footnoteMatches || 0}</div></div>
                        <div><div style="font-size: 0.9rem; color: #94a3b8;">Match Rate</div><div style="font-size: 1.8rem; font-weight: bold; color: #22c55e;">${job.qualityMetrics.footnoteMatchRate || 0}%</div></div>
                        <div><div style="font-size: 0.9rem; color: #94a3b8;">FN Removed</div><div style="font-size: 1.8rem; font-weight: bold; color: #fb923c;">${job.qualityMetrics.footnoteTextItemsRemoved || 0}</div></div>
                        <div><div style="font-size: 0.9rem; color: #94a3b8;">Overall</div><div style="font-size: 1.8rem; font-weight: bold; color: #22c55e;">${job.qualityMetrics.overallScore}%</div></div>
                    </div>
                    <div style="margin-top: 15px; font-size: 0.9rem; color: #cbd5e1;">
                        ‚úì Fixed ${job.qualityMetrics.issuesFixed} text artifacts
                        ${job.linkMetadata ? ` ‚Ä¢ üåê ${job.linkMetadata.linksPreserved} external links preserved` : ''}
                        ${job.advancedMetadata?.headersFootersRemoved ? ` ‚Ä¢ üßπ ${job.advancedMetadata.headersFootersRemoved} headers/footers removed` : ''}
                        ${job.advancedMetadata?.footnoteMarkersDetected ? ` ‚Ä¢ üîç ${job.advancedMetadata.footnoteMarkersDetected} markers detected` : ''}
                        ${job.advancedMetadata?.footnotesDetected ? ` ‚Ä¢ üìù ${job.advancedMetadata.footnotesDetected} footnotes extracted` : ''}
                        ${job.advancedMetadata?.footnoteMatches ? ` ‚Ä¢ üîó ${job.advancedMetadata.footnoteMatches} matched (Task 3)` : ''}
                        ${job.advancedMetadata?.footnoteTextItemsRemoved ? ` ‚Ä¢ üßπ ${job.advancedMetadata.footnoteTextItemsRemoved} items removed (Task 4)` : ''}
                    </div>
                </div>
            ` : '';
            previewWindow.document.write(`
                <!DOCTYPE html>
                <html><head><title>${job.filename} - v2.3.1 Task 4 Preview</title>
                <style>body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;max-width:900px;margin:40px auto;padding:20px;background:#0f172a;color:#f1f5f9;line-height:1.6}pre{background:#1e293b;padding:20px;border-radius:8px;overflow-x:auto;white-space:pre-wrap;word-wrap:break-word;border:1px solid #475569}h1{color:#38bdf8;margin-bottom:20px}h2{color:#38bdf8;margin-top:2em}a{color:#a855f7;text-decoration:none;border-bottom:1px dashed #a855f7}a:hover{color:#c084fc;border-bottom-style:solid}</style>
                </head><body><h1>üìÑ ${job.filename}</h1>${metricsHTML}<pre>${job.result.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre></body></html>
            `);
        }

        function deleteJob(jobId) {
            const index = jobs.findIndex(j => j.id == jobId);
            if (index !== -1) {
                jobs.splice(index, 1);
                updateUI();
            }
        }

        updateUI();
    </script>
</body>
</html>