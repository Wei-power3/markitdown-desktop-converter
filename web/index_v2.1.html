<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MarkItDown v2.1 Enhanced Converter</title>
    <style>
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-elevated: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --accent-blue: #38bdf8;
            --accent-green: #22c55e;
            --accent-red: #ef4444;
            --accent-yellow: #facc15;
            --border: #475569;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .version-badge {
            background: var(--accent-blue);
            color: var(--bg-primary);
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
            margin-bottom: 15px;
        }

        .features {
            display: flex;
            gap: 20px;
            font-size: 0.9rem;
            color: var(--text-muted);
            flex-wrap: wrap;
        }

        .feature {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .new-badge {
            background: var(--accent-green);
            color: var(--bg-primary);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 700;
            margin-left: 4px;
        }

        .dropzone {
            background: var(--bg-secondary);
            border: 3px dashed var(--border);
            border-radius: 12px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 30px;
        }

        .dropzone:hover {
            border-color: var(--accent-blue);
            background: rgba(56, 189, 248, 0.05);
            transform: translateY(-2px);
        }

        .dropzone.drag-over {
            border-color: var(--accent-blue);
            background: rgba(56, 189, 248, 0.1);
            transform: scale(1.02);
        }

        .dropzone-icon {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .dropzone-text {
            font-size: 1.3rem;
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .dropzone-hint {
            color: var(--text-muted);
            font-size: 0.95rem;
        }

        .supported-formats {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .format-badge {
            background: var(--bg-elevated);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 20px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .job-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.2s ease;
        }

        .job-item:hover {
            border-color: var(--accent-blue);
        }

        .job-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 15px;
        }

        .job-info {
            flex: 1;
            min-width: 0;
        }

        .job-filename {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
            word-break: break-word;
        }

        .job-meta {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .status-badge {
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            white-space: nowrap;
        }

        .status-processing {
            background: rgba(56, 189, 248, 0.2);
            color: var(--accent-blue);
        }

        .status-completed {
            background: rgba(34, 197, 94, 0.2);
            color: var(--accent-green);
        }

        .status-error {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-red);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-elevated);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-blue);
            transition: width 0.3s ease;
            border-radius: 4px;
        }

        .progress-fill.completed {
            background: var(--accent-green);
        }

        .quality-metrics {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin: 15px 0;
        }

        .metric {
            background: var(--bg-elevated);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .metric-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 6px;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
        }

        .metric-value.excellent {
            color: var(--accent-green);
        }

        .metric-value.good {
            color: var(--accent-blue);
        }

        .metric-value.warning {
            color: var(--accent-yellow);
        }

        .metric-value.poor {
            color: var(--accent-red);
        }

        .enhancements-list {
            background: rgba(56, 189, 248, 0.1);
            border: 1px solid var(--accent-blue);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }

        .enhancements-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-blue);
            margin-bottom: 8px;
        }

        .enhancement-item {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin: 4px 0;
            padding-left: 16px;
            position: relative;
        }

        .enhancement-item:before {
            content: '‚úì';
            position: absolute;
            left: 0;
            color: var(--accent-green);
            font-weight: bold;
        }

        .job-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: var(--accent-blue);
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            background: #0ea5e9;
            transform: translateY(-1px);
        }

        .btn-success {
            background: var(--accent-green);
            color: var(--bg-primary);
        }

        .btn-success:hover {
            background: #16a34a;
            transform: translateY(-1px);
        }

        .btn-danger {
            background: transparent;
            color: var(--accent-red);
            border: 1px solid var(--accent-red);
        }

        .btn-danger:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        .empty-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .error-message {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid var(--accent-red);
            color: var(--accent-red);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        input[type="file"] {
            display: none;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .spinner {
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8rem;
            }

            .features {
                font-size: 0.8rem;
            }

            .dropzone {
                padding: 40px 20px;
            }

            .stats {
                grid-template-columns: repeat(2, 1fr);
            }

            .quality-metrics {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>
                üìÑ MarkItDown Enhanced Converter
                <span class="version-badge">v2.1.0</span>
            </h1>
            <p class="subtitle">Professional-grade PDF/PowerPoint to Markdown with intelligent structure detection</p>
            <div class="features">
                <span class="feature">‚úì Smart Header Detection<span class="new-badge">NEW</span></span>
                <span class="feature">‚úì List Recognition<span class="new-badge">NEW</span></span>
                <span class="feature">‚úì Academic Format<span class="new-badge">NEW</span></span>
                <span class="feature">‚úì Bold/Italic Support<span class="new-badge">NEW</span></span>
                <span class="feature">‚úì Text Cleaning (v2.0)</span>
                <span class="feature">‚úì Quality Metrics</span>
                <span class="feature">‚úì No Upload ‚Ä¢ Complete Privacy</span>
            </div>
        </header>

        <div id="dropzone" class="dropzone">
            <div class="dropzone-icon">üìÅ</div>
            <div class="dropzone-text">Drag & Drop files here</div>
            <div class="dropzone-hint">or click to browse</div>
            <div class="supported-formats">
                <span class="format-badge">PDF</span>
                <span class="format-badge">PPTX</span>
                <span class="format-badge">PPT</span>
            </div>
            <input type="file" id="fileInput" accept=".pdf,.pptx,.ppt" multiple>
        </div>

        <div class="stats" id="stats">
            <div class="stat-card">
                <div class="stat-value" id="totalFiles">0</div>
                <div class="stat-label">Total Files</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="processing">0</div>
                <div class="stat-label">Processing</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="completed">0</div>
                <div class="stat-label">Completed</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="failed">0</div>
                <div class="stat-label">Failed</div>
            </div>
        </div>

        <div id="jobList"></div>

        <div class="empty-state" id="emptyState">
            <div class="empty-icon">üì≠</div>
            <p>No files yet. Drop some files above to get started!</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Global state
        const jobs = [];

        // DOM elements
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');
        const jobList = document.getElementById('jobList');
        const emptyState = document.getElementById('emptyState');

        // ===== TEXT CLEANING (from v2.0) =====
        class TextCleaner {
            constructor() {
                this.issuesFixed = 0;
            }

            clean(text) {
                this.issuesFixed = 0;
                let cleaned = text;

                // Fix ligatures
                const ligatures = {
                    'Ô¨Å': 'fi', 'Ô¨Ç': 'fl', 'Ô¨Ä': 'ff', 'Ô¨É': 'ffi', 'Ô¨Ñ': 'ffl',
                    'Ô¨Ü': 'st'
                };
                for (const [lig, replacement] of Object.entries(ligatures)) {
                    const count = (cleaned.match(new RegExp(lig, 'g')) || []).length;
                    if (count > 0) this.issuesFixed += count;
                    cleaned = cleaned.replace(new RegExp(lig, 'g'), replacement);
                }

                // Fix hyphenation breaks
                const hyphenPattern = /(\w+)- +(\w+)/g;
                const hyphenMatches = cleaned.match(hyphenPattern) || [];
                this.issuesFixed += hyphenMatches.length;
                cleaned = cleaned.replace(hyphenPattern, '$1-$2');

                // Fix spaced words
                const spacedPattern = /(\w) +(\w)(?= |\.|,|;|:)/g;
                cleaned = cleaned.replace(spacedPattern, (match, p1, p2) => {
                    if (match.length <= 5) {
                        this.issuesFixed++;
                        return p1 + p2;
                    }
                    return match;
                });

                // Fix encoding issues
                const encodingFixes = {
                    '√¢‚Ç¨‚Ñ¢': "'", '√¢‚Ç¨≈ì': '"', '√¢‚Ç¨¬ù': '"', '√¢‚Ç¨"': '‚Äî',
                    '√Ç': '', '√¢‚Ç¨¬¢': '‚Ä¢'
                };
                for (const [bad, good] of Object.entries(encodingFixes)) {
                    const count = (cleaned.match(new RegExp(bad, 'g')) || []).length;
                    if (count > 0) this.issuesFixed += count;
                    cleaned = cleaned.replace(new RegExp(bad, 'g'), good);
                }

                return cleaned;
            }
        }

        // ===== STRUCTURE DETECTION (v2.1 - from jzillmann/pdf-to-markdown) =====
        
        // List detection patterns
        function isListItemCharacter(char) {
            return ['‚Ä¢', '-', '‚Äì', '‚ñ™', '‚ó¶', '‚óã', '‚ñ†', '‚ñ°'].includes(char);
        }

        function isListItem(line) {
            return /^[\s]*[-‚Ä¢‚Äì‚ñ™‚ó¶‚óã‚ñ†‚ñ°][\s].*$/g.test(line);
        }

        function isNumberedListItem(line) {
            return /^[\s]*[\d]+[.)][\s].*$/g.test(line) || /^[\s]*[a-z][.)][\s].*$/i.test(line);
        }

        // Academic section keywords
        const ACADEMIC_KEYWORDS = [
            'Abstract', 'Introduction', 'Background', 'Methods', 'Methodology',
            'Materials and Methods', 'Results', 'Discussion', 'Conclusion',
            'Conclusions', 'References', 'Bibliography', 'Acknowledgments',
            'Acknowledgements', 'Appendix', 'Supplementary', 'Summary'
        ];

        function isAcademicSection(line) {
            const trimmed = line.trim();
            return ACADEMIC_KEYWORDS.some(keyword => 
                trimmed.toLowerCase() === keyword.toLowerCase() ||
                trimmed.toLowerCase() === keyword.toLowerCase() + ':'
            );
        }

        // Font name analysis for bold/italic
        function getFontStyle(fontName) {
            if (!fontName) return null;
            const name = fontName.toLowerCase();
            
            const isBold = name.includes('bold') || name.includes('-b') || name.includes('heavy');
            const isItalic = name.includes('italic') || name.includes('oblique') || name.includes('-i');
            
            if (isBold && isItalic) return 'bold-italic';
            if (isBold) return 'bold';
            if (isItalic) return 'italic';
            return null;
        }

        // Header detection based on font size
        function detectHeaderLevel(fontSize, avgFontSize) {
            if (fontSize >= avgFontSize * 1.8) return 1; // # H1
            if (fontSize >= avgFontSize * 1.5) return 2; // ## H2
            if (fontSize >= avgFontSize * 1.2) return 3; // ### H3
            return null;
        }

        // ALL CAPS detection
        function isAllCaps(text) {
            const letters = text.replace(/[^a-zA-Z]/g, '');
            if (letters.length < 3) return false;
            return letters === letters.toUpperCase();
        }

        // Quality scoring
        function calculateQualityMetrics(markdown, enhancements) {
            const lines = markdown.split('\n');
            const totalChars = markdown.length;
            
            // Text quality (based on cleaning)
            const cleanScore = Math.min(100, 95 + (enhancements.issuesFixed === 0 ? 5 : 0));
            
            // Structure score
            let structurePoints = 0;
            const headers = (markdown.match(/^#{1,6} /gm) || []).length;
            const lists = (markdown.match(/^[-‚Ä¢] /gm) || []).length;
            const numberedLists = (markdown.match(/^\d+\. /gm) || []).length;
            const bold = (markdown.match(/\*\*.*?\*\*/g) || []).length;
            const italic = (markdown.match(/\*.*?\*/g) || []).length;
            
            if (headers > 0) structurePoints += Math.min(30, headers * 5);
            if (lists > 0) structurePoints += Math.min(25, lists * 2);
            if (numberedLists > 0) structurePoints += Math.min(20, numberedLists * 2);
            if (bold > 0) structurePoints += Math.min(15, bold * 1);
            if (italic > 0) structurePoints += Math.min(10, italic * 1);
            
            const structureScore = Math.min(100, structurePoints);
            
            // Overall (weighted average)
            const overallScore = Math.round(cleanScore * 0.6 + structureScore * 0.4);
            
            return {
                textQuality: cleanScore,
                structure: structureScore,
                overall: overallScore,
                details: {
                    headers,
                    lists: lists + numberedLists,
                    formatting: bold + italic
                }
            };
        }

        function getScoreClass(score) {
            if (score >= 90) return 'excellent';
            if (score >= 70) return 'good';
            if (score >= 50) return 'warning';
            return 'poor';
        }

        // ===== PDF CONVERSION WITH STRUCTURE DETECTION =====
        async function convertPDF(job) {
            job.progress = 10;
            updateUI();

            const arrayBuffer = await job.file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            
            const cleaner = new TextCleaner();
            let markdown = `# ${job.filename}\n\n`;
            markdown += `Converted from PDF ‚Ä¢ ${pdf.numPages} pages ‚Ä¢ Enhanced v2.1\n\n---\n\n`;

            // First pass: collect font sizes for average calculation
            let fontSizes = [];
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                textContent.items.forEach(item => {
                    if (item.transform && item.transform[0]) {
                        fontSizes.push(Math.abs(item.transform[0]));
                    }
                });
            }
            const avgFontSize = fontSizes.reduce((a, b) => a + b, 0) / fontSizes.length || 12;

            const enhancements = {
                issuesFixed: 0,
                headersDetected: 0,
                listsDetected: 0,
                stylingApplied: 0
            };

            // Second pass: convert with structure detection
            for (let i = 1; i <= pdf.numPages; i++) {
                job.progress = 10 + (80 * (i / pdf.numPages));
                updateUI();

                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                
                markdown += `## Page ${i}\n\n`;
                
                // Group items into lines
                const lines = [];
                let currentLine = [];
                let lastY = null;
                
                textContent.items.forEach(item => {
                    const y = item.transform[5];
                    if (lastY !== null && Math.abs(y - lastY) > 5) {
                        if (currentLine.length > 0) {
                            lines.push(currentLine);
                            currentLine = [];
                        }
                    }
                    currentLine.push(item);
                    lastY = y;
                });
                if (currentLine.length > 0) lines.push(currentLine);

                // Process each line
                for (const lineItems of lines) {
                    let lineText = '';
                    let lineFontSize = 0;
                    let fontStyles = [];

                    lineItems.forEach(item => {
                        const fontSize = Math.abs(item.transform[0]);
                        lineFontSize = Math.max(lineFontSize, fontSize);
                        
                        let text = item.str;
                        const fontStyle = getFontStyle(item.fontName);
                        
                        if (fontStyle === 'bold') {
                            text = `**${text}**`;
                            enhancements.stylingApplied++;
                        } else if (fontStyle === 'italic') {
                            text = `*${text}*`;
                            enhancements.stylingApplied++;
                        } else if (fontStyle === 'bold-italic') {
                            text = `***${text}***`;
                            enhancements.stylingApplied++;
                        }
                        
                        lineText += text;
                    });

                    lineText = lineText.trim();
                    if (!lineText) continue;

                    // Clean the text
                    lineText = cleaner.clean(lineText);

                    // Detect structure
                    const headerLevel = detectHeaderLevel(lineFontSize, avgFontSize);
                    const isAcademic = isAcademicSection(lineText);
                    const isList = isListItem(lineText);
                    const isNumbered = isNumberedListItem(lineText);
                    const allCaps = isAllCaps(lineText) && lineText.length > 3 && lineText.length < 100;

                    // Apply formatting
                    if (isAcademic) {
                        markdown += `## ${lineText}\n\n`;
                        enhancements.headersDetected++;
                    } else if (headerLevel) {
                        const hashes = '#'.repeat(headerLevel + 1); // +1 because page title is H2
                        markdown += `${hashes} ${lineText}\n\n`;
                        enhancements.headersDetected++;
                    } else if (allCaps && lineFontSize > avgFontSize * 1.1) {
                        // Convert ALL CAPS to Title Case for headers
                        const titleCase = lineText.toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
                        markdown += `### ${titleCase}\n\n`;
                        enhancements.headersDetected++;
                    } else if (isList) {
                        markdown += `${lineText}\n`;
                        enhancements.listsDetected++;
                    } else if (isNumbered) {
                        markdown += `${lineText}\n`;
                        enhancements.listsDetected++;
                    } else {
                        markdown += `${lineText}\n\n`;
                    }
                }
                
                markdown += '\n';
            }

            enhancements.issuesFixed = cleaner.issuesFixed;
            job.progress = 90;
            updateUI();

            return { markdown, enhancements };
        }

        // ===== PPTX CONVERSION (Basic) =====
        async function convertPPTX(job) {
            job.progress = 20;
            updateUI();

            const arrayBuffer = await job.file.arrayBuffer();
            const zip = await JSZip.loadAsync(arrayBuffer);
            
            const cleaner = new TextCleaner();
            let markdown = `# ${job.filename}\n\n`;
            markdown += `Converted from PowerPoint ‚Ä¢ Enhanced v2.1\n\n---\n\n`;

            const slideFiles = Object.keys(zip.files)
                .filter(name => name.startsWith('ppt/slides/slide') && name.endsWith('.xml'))
                .sort((a, b) => {
                    const numA = parseInt(a.match(/slide(\d+)/)[1]);
                    const numB = parseInt(b.match(/slide(\d+)/)[1]);
                    return numA - numB;
                });

            const enhancements = {
                issuesFixed: 0,
                headersDetected: slideFiles.length,
                listsDetected: 0,
                stylingApplied: 0
            };

            for (let i = 0; i < slideFiles.length; i++) {
                job.progress = 20 + (70 * ((i + 1) / slideFiles.length));
                updateUI();

                const slideXml = await zip.files[slideFiles[i]].async('text');
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(slideXml, 'text/xml');
                
                markdown += `## Slide ${i + 1}\n\n`;
                
                const textElements = xmlDoc.getElementsByTagName('a:t');
                const texts = Array.from(textElements)
                    .map(el => el.textContent.trim())
                    .filter(text => text.length > 0);
                
                if (texts.length > 0) {
                    texts.forEach(text => {
                        text = cleaner.clean(text);
                        if (isListItem(text) || isNumberedListItem(text)) {
                            markdown += `${text}\n`;
                            enhancements.listsDetected++;
                        } else {
                            markdown += `${text}\n\n`;
                        }
                    });
                } else {
                    markdown += '*[No text content on this slide]*\n\n';
                }
                
                markdown += '\n';
            }

            enhancements.issuesFixed = cleaner.issuesFixed;
            job.progress = 90;
            updateUI();

            return { markdown, enhancements };
        }

        // ===== JOB MANAGEMENT =====
        function addJob(file) {
            const job = {
                id: Date.now() + Math.random(),
                filename: file.name,
                file: file,
                status: 'processing',
                progress: 0,
                result: null,
                enhancements: null,
                metrics: null,
                error: null,
                createdAt: new Date()
            };

            jobs.unshift(job);
            updateUI();
            processFile(job);
        }

        async function processFile(job) {
            try {
                job.progress = 10;
                updateUI();

                const extension = job.filename.split('.').pop().toLowerCase();
                let result;

                if (extension === 'pdf') {
                    result = await convertPDF(job);
                } else if (extension === 'pptx' || extension === 'ppt') {
                    result = await convertPPTX(job);
                }

                job.result = result.markdown;
                job.enhancements = result.enhancements;
                job.metrics = calculateQualityMetrics(result.markdown, result.enhancements);
                job.progress = 100;
                job.status = 'completed';
                updateUI();

            } catch (error) {
                console.error('Conversion error:', error);
                job.status = 'error';
                job.error = error.message || 'Conversion failed';
                updateUI();
            }
        }

        function handleFiles(files) {
            files.forEach(file => {
                const extension = file.name.split('.').pop().toLowerCase();
                if (['pdf', 'pptx', 'ppt'].includes(extension)) {
                    addJob(file);
                } else {
                    alert(`Unsupported file type: ${file.name}`);
                }
            });
        }

        // ===== UI UPDATES =====
        function updateUI() {
            // Update stats
            document.getElementById('totalFiles').textContent = jobs.length;
            document.getElementById('processing').textContent = jobs.filter(j => j.status === 'processing').length;
            document.getElementById('completed').textContent = jobs.filter(j => j.status === 'completed').length;
            document.getElementById('failed').textContent = jobs.filter(j => j.status === 'error').length;

            // Update job list
            if (jobs.length === 0) {
                emptyState.style.display = 'block';
                jobList.innerHTML = '';
            } else {
                emptyState.style.display = 'none';
                jobList.innerHTML = jobs.map(job => renderJob(job)).join('');
            }
        }

        function renderJob(job) {
            const statusConfig = {
                processing: { icon: '‚è≥', class: 'status-processing', label: 'Processing' },
                completed: { icon: '‚úî', class: 'status-completed', label: 'Completed' },
                error: { icon: '‚úñ', class: 'status-error', label: 'Failed' }
            };

            const config = statusConfig[job.status];
            const fileSize = (job.file.size / 1024).toFixed(1) + ' KB';
            const time = job.createdAt.toLocaleTimeString();

            let metricsHTML = '';
            if (job.metrics) {
                metricsHTML = `
                    <div class="quality-metrics">
                        <div class="metric">
                            <div class="metric-label">Text Quality</div>
                            <div class="metric-value ${getScoreClass(job.metrics.textQuality)}">
                                ${job.metrics.textQuality}%
                            </div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Structure</div>
                            <div class="metric-value ${getScoreClass(job.metrics.structure)}">
                                ${job.metrics.structure}%
                            </div>
                        </div>
                        <div class="metric">
                            <div class="metric-label">Overall</div>
                            <div class="metric-value ${getScoreClass(job.metrics.overall)}">
                                ${job.metrics.overall}%
                            </div>
                        </div>
                    </div>
                `;
            }

            let enhancementsHTML = '';
            if (job.enhancements) {
                const items = [];
                if (job.enhancements.issuesFixed > 0) {
                    items.push(`Fixed ${job.enhancements.issuesFixed} text artifacts`);
                }
                if (job.enhancements.headersDetected > 0) {
                    items.push(`Detected ${job.enhancements.headersDetected} headers`);
                }
                if (job.enhancements.listsDetected > 0) {
                    items.push(`Found ${job.enhancements.listsDetected} list items`);
                }
                if (job.enhancements.stylingApplied > 0) {
                    items.push(`Applied ${job.enhancements.stylingApplied} bold/italic styles`);
                }

                if (items.length > 0) {
                    enhancementsHTML = `
                        <div class="enhancements-list">
                            <div class="enhancements-title">‚ú® v2.1 Enhancements Applied</div>
                            ${items.map(item => `<div class="enhancement-item">${item}</div>`).join('')}
                        </div>
                    `;
                }
            }

            return `
                <div class="job-item">
                    <div class="job-header">
                        <div class="job-info">
                            <div class="job-filename">
                                <span>${config.icon}</span>
                                <span>${job.filename}</span>
                            </div>
                            <div class="job-meta">${fileSize} ‚Ä¢ ${time}</div>
                        </div>
                        <span class="status-badge ${config.class}">${config.label}</span>
                    </div>

                    <div class="progress-bar">
                        <div class="progress-fill ${job.status === 'completed' ? 'completed' : ''}" 
                             style="width: ${job.progress}%"></div>
                    </div>

                    ${metricsHTML}
                    ${enhancementsHTML}

                    ${job.error ? `
                        <div class="error-message">
                            <strong>Error:</strong> ${job.error}
                        </div>
                    ` : ''}

                    <div class="job-actions">
                        ${job.status === 'completed' ? `
                            <button class="btn btn-success" onclick="downloadMarkdown('${job.id}')">
                                ‚¨á Download Markdown
                            </button>
                            <button class="btn btn-primary" onclick="viewMarkdown('${job.id}')">
                                üëÅ Preview
                            </button>
                        ` : ''}
                        ${job.status !== 'processing' ? `
                            <button class="btn btn-danger" onclick="deleteJob('${job.id}')">
                                üóë Delete
                            </button>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function downloadMarkdown(jobId) {
            const job = jobs.find(j => j.id == jobId);
            if (!job || !job.result) return;

            const blob = new Blob([job.result], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = job.filename.replace(/\.[^.]+$/, '') + '_v2.1_enhanced.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function viewMarkdown(jobId) {
            const job = jobs.find(j => j.id == jobId);
            if (!job || !job.result) return;

            const previewWindow = window.open('', '_blank');
            previewWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>${job.filename} - Preview (v2.1)</title>
                    <style>
                        body {
                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                            max-width: 900px;
                            margin: 40px auto;
                            padding: 20px;
                            background: #0f172a;
                            color: #f1f5f9;
                            line-height: 1.6;
                        }
                        pre {
                            background: #1e293b;
                            padding: 20px;
                            border-radius: 8px;
                            overflow-x: auto;
                            white-space: pre-wrap;
                            word-wrap: break-word;
                        }
                        h1 { color: #38bdf8; }
                        h2 { color: #38bdf8; margin-top: 2em; }
                        h3 { color: #22c55e; }
                        .badge {
                            background: #38bdf8;
                            color: #0f172a;
                            padding: 4px 8px;
                            border-radius: 4px;
                            font-size: 0.85rem;
                            font-weight: 600;
                        }
                    </style>
                </head>
                <body>
                    <h1>üìÑ ${job.filename} <span class="badge">v2.1</span></h1>
                    <pre>${job.result.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</pre>
                </body>
                </html>
            `);
        }

        function deleteJob(jobId) {
            const index = jobs.findIndex(j => j.id == jobId);
            if (index !== -1) {
                jobs.splice(index, 1);
                updateUI();
            }
        }

        // ===== EVENT LISTENERS =====
        dropzone.addEventListener('click', () => fileInput.click());
        
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('drag-over');
        });

        dropzone.addEventListener('dragleave', () => {
            dropzone.classList.remove('drag-over');
        });

        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files);
            handleFiles(files);
        });

        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            handleFiles(files);
            fileInput.value = '';
        });

        // Initialize UI
        updateUI();
    </script>
</body>
</html>